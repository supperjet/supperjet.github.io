<!DOCTYPE html>
<html>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本文章转载自webglfundamentals.org, 为了个人阅读方便将此文章转载至此，承诺不用于商业用途，也不希望他人将其外链或用于任何商业用途。  WebGL经常被当成3D API，人们总想“我可以使用WebGL和一些神奇的东西做出炫酷的3D作品”。 事实上WebGL仅仅是一个光栅化引擎，它可以根据你的代码绘制出点，线和三角形。 想要利用WebGL完成更复杂任务，取决于你能否提供合适的代">
<meta name="keywords" content="webgl">
<meta property="og:type" content="article">
<meta property="og:title" content="webgl基础概念">
<meta property="og:url" content="http://yoursite.com/2017/08/17/webgl基础概念/index.html">
<meta property="og:site_name" content="一只会飞的鱼">
<meta property="og:description" content="本文章转载自webglfundamentals.org, 为了个人阅读方便将此文章转载至此，承诺不用于商业用途，也不希望他人将其外链或用于任何商业用途。  WebGL经常被当成3D API，人们总想“我可以使用WebGL和一些神奇的东西做出炫酷的3D作品”。 事实上WebGL仅仅是一个光栅化引擎，它可以根据你的代码绘制出点，线和三角形。 想要利用WebGL完成更复杂任务，取决于你能否提供合适的代">
<meta property="og:updated_time" content="2017-08-17T02:44:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="webgl基础概念">
<meta name="twitter:description" content="本文章转载自webglfundamentals.org, 为了个人阅读方便将此文章转载至此，承诺不用于商业用途，也不希望他人将其外链或用于任何商业用途。  WebGL经常被当成3D API，人们总想“我可以使用WebGL和一些神奇的东西做出炫酷的3D作品”。 事实上WebGL仅仅是一个光栅化引擎，它可以根据你的代码绘制出点，线和三角形。 想要利用WebGL完成更复杂任务，取决于你能否提供合适的代">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>webgl基础概念</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/js/">JS</a></li>
         
          <li><a href="/tags/canvas/">Canvas</a></li>
         
          <li><a href="/tags/webgl/">Webgl</a></li>
         
          <li><a href="/tags/vue/">Vue</a></li>
         
          <li><a href="/tags/react/">React</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2017/08/17/每周一点canvas动画-波形运动/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2017/08/17/每周一点canvas动画-三角函数/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2017/08/17/webgl基础概念/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2017/08/17/webgl基础概念/&text=webgl基础概念"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2017/08/17/webgl基础概念/&is_video=false&description=webgl基础概念"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=webgl基础概念&body=Check out this article: http://yoursite.com/2017/08/17/webgl基础概念/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2017/08/17/webgl基础概念/&name=webgl基础概念&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、WebGL-Hello-World"><span class="toc-number">1.</span> <span class="toc-text">1、WebGL Hello World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、渲染"><span class="toc-number">2.</span> <span class="toc-text">2、渲染</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        webgl基础概念
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">一只会飞的鱼</span>
      </span>
      
    <div class="postdate">
        <time datetime="2017-08-17T01:24:01.000Z" itemprop="datePublished">2017-08-17</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/webgl/">webgl</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>本文章转载自<a href="https://webglfundamentals.org/webgl/lessons/zh_cn/index.html" target="_blank" rel="external">webglfundamentals.org</a>, 为了个人阅读方便将此文章转载至此，承诺不用于商业用途，也不希望他人将其外链或用于任何商业用途。</p>
</blockquote>
<p>WebGL经常被当成3D API，人们总想“我可以使用WebGL和一些神奇的东西做出炫酷的3D作品”。 事实上WebGL仅仅是一个光栅化引擎，它可以根据你的代码绘制出点，线和三角形。 想要利用WebGL完成更复杂任务，取决于你能否提供合适的代码，组合使用点，线和三角形代替实现。</p>
<p>WebGL在电脑的GPU中运行。因此你需要使用能够在GPU上运行的代码。 这样的代码需要提供成对的方法。每对方法中一个叫顶点着色器， 另一个叫片段着色器，并且使用一种和C或C++类似的强类型的语言 GLSL。 (GL着色语言)。 每一对组合起来称作一个 program（着色程序）。</p>
<p>顶点着色器的作用是计算顶点的位置。根据计算出的一系列顶点位置，WebGL可以对点， 线和三角形在内的一些图元进行光栅化处理。当对这些图元进行光栅化处理时需要使用片断着色器方法。 片断着色器的作用是计算出当前绘制图元中每个像素的颜色值。</p>
<p>几乎整个WebGL API都是关于如何设置这些成对方法的状态值以及运行它们。 对于想要绘制的每一个对象，都需要先设置一系列状态值，然后通过调用 gl.drawArrays 或 gl.drawElements 运行一个着色方法对，使得你的着色器对能够在GPU上运行。</p>
<p>这些方法对所需的任何数据都需要发送到GPU，这里有着色器获取数据的4种方法。</p>
<p>1、属性（Attributes）和缓冲</p>
<p>缓冲是发送到GPU的一些二进制数据序列，通常情况下缓冲数据包括位置，法向量，纹理坐标，顶点颜色值等。 你可以存储任何数据。</p>
<p>属性用来指明怎么从缓冲中获取所需数据并将它提供给顶点着色器。 例如你可能在缓冲中用三个32位的浮点型数据存储一个位置值。 对于一个确切的属性你需要告诉它从哪个缓冲中获取数据，获取什么类型的数据（三个32位的浮点数据）， 起始偏移值是多少，到下一个位置的字节数是多少。</p>
<p>缓冲不是随意读取的。事实上顶点着色器运行的次数是一个指定的确切数字， 每一次运行属性会从指定的缓冲中按照指定规则依次获取下一个值。</p>
<p>2、全局变量（Uniforms）</p>
<p>全局变量在着色程序运行前赋值，在运行过程中全局有效。</p>
<p>3、纹理（Textures）</p>
<p>纹理是一个数据序列，可以在着色程序运行中随意读取其中的数据。 大多数情况存放的是图像数据，但是纹理仅仅是数据序列， 你也可以随意存放除了颜色数据以外的其它数据。<br>4、可变量（Varyings）</p>
<p>可变量是一种顶点着色器给片断着色器传值的方式，依照渲染的图元是点， 线还是三角形，顶点着色器中设置的可变量会在片段着色器运行中获取不同的插值。</p>
<h2 id="1、WebGL-Hello-World"><a href="#1、WebGL-Hello-World" class="headerlink" title="1、WebGL Hello World"></a>1、WebGL Hello World</h2><p>WebGL只关心两件事：裁剪空间中的坐标值和颜色值。使用WebGL只需要给它提供这两个东西。 你需要提供两个着色器来做这两件事，一个顶点着色器提供裁剪空间坐标值，一个片断着色器提供颜色值。</p>
<p>无论你的画布有多大，裁剪空间的坐标范围永远是 -1 到 1 。 这里有一个简单的WebGL例子展示WebGL的简单用法。</p>
<p>让我们从顶点着色器开始</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个属性值，将会从缓冲中获取数据</span></div><div class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_position;</div><div class="line"> </div><div class="line"><span class="comment">// 所有着色器都有一个main方法</span></div><div class="line"><span class="type">void</span> main() &#123;</div><div class="line"> </div><div class="line">  <span class="comment">// gl_Position 是一个顶点着色器主要设置的变量</span></div><div class="line">  <span class="built_in">gl_Position</span> = a_position;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果用JavaScript代替GLSL，当它运行的时候，你可以想象它做了类似以下的事情</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// *** 伪代码!! ***</span></div><div class="line"> </div><div class="line">var positionBuffer = [</div><div class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</div><div class="line">  <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>,</div><div class="line">  <span class="number">0.7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</div><div class="line">];</div><div class="line">var attributes = &#123;&#125;;</div><div class="line">var gl_Position;</div><div class="line"> </div><div class="line">drawArrays(..., offset, count) &#123;</div><div class="line">  var stride = <span class="number">4</span>;</div><div class="line">  var size = <span class="number">4</span>;</div><div class="line">  for (var i = <span class="number">0</span>; i &lt; count; ++i) &#123;</div><div class="line">     <span class="comment">// 从positionBuffer复制接下来4个值给a_position属性</span></div><div class="line">     attributes.a_position = positionBuffer.slice((offset + i) * stride, size);</div><div class="line">     runVertexShader();<span class="comment">// 运行顶点着色器</span></div><div class="line">     ...</div><div class="line">     doSomethingWith_gl_Position();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际情况没有那么简单，因为 positionBuffer 将会被转换成二进制数据（见下文）， 所以真实情况下从缓冲中读取数据有些麻烦，但是希望这个例子能够让你想象出顶点着色器是怎么执行的。</p>
<p>接下来我们需要一个片段着色器</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 片断着色器没有默认精度，所以我们需要设置一个精度</span></div><div class="line"><span class="comment">// mediump是一个不错的默认值，代表“medium precision”（中等精度）</span></div><div class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</div><div class="line"> </div><div class="line"><span class="type">void</span> main() &#123;</div><div class="line">  <span class="comment">// gl_FragColor是一个片段着色器主要设置的变量</span></div><div class="line">  <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>); <span class="comment">// 返回“瑞迪施紫色”</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上方我们设置 gl_FragColor 为 1, 0, 0.5, 1，其中1代表红色值，0代表绿色值， 0.5代表蓝色值，最后一个1表示阿尔法通道值。WebGL中的颜色值范围从 0 到 1 。</p>
<p>现在我们有了两个着色器方法，让我们开始使用WebGL吧</p>
<p>首先我们需要一个HTML中的canvas（画布）对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;canvas id=<span class="string">"c"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>然后可以用JavaScript获取它</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"c"</span>);</div></pre></td></tr></table></figure>
<p>现在我们创建一个WebGL渲染上下文（WebGLRenderingContext）</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">gl</span> = canvas.getContext(<span class="string">"webgl"</span>);</div><div class="line"> <span class="keyword">if</span> (!<span class="keyword">gl</span>) &#123;</div><div class="line">    <span class="comment">// 你不能使用WebGL！</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>现在我们需要编译着色器对然后提交到GPU，先让我们通过字符串获取它们。 你可以利用JavaScript中创建字符串的方式创建GLSL字符串：用串联的方式（concatenating）， 用AJAX下载，用多行模板数据。或者在这个例子里，将它们放在非JavaScript类型的标签中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"2d-vertex-shader"</span> <span class="attr">type</span>=<span class="string">"notjs"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">  <span class="comment">// 一个属性变量，将会从缓冲中获取数据</span></span></div><div class="line"><span class="undefined">  attribute vec4 a_position;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">  <span class="comment">// 所有着色器都有一个main方法</span></span></div><div class="line"><span class="actionscript">  <span class="keyword">void</span> main() &#123;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">    <span class="comment">// gl_Position 是一个顶点着色器主要设置的变量</span></span></div><div class="line"><span class="undefined">    gl_Position = a_position;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"2d-fragment-shader"</span> <span class="attr">type</span>=<span class="string">"notjs"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">  <span class="comment">// 片断着色器没有默认精度，所以我们需要设置一个精度</span></span></div><div class="line"><span class="actionscript">  <span class="comment">// mediump是一个不错的默认值，代表“medium precision”（中等精度）</span></span></div><div class="line"><span class="undefined">  precision mediump float;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">  <span class="keyword">void</span> main() &#123;</span></div><div class="line"><span class="actionscript">    <span class="comment">// gl_FragColor是一个片段着色器主要设置的变量</span></span></div><div class="line"><span class="actionscript">    gl_FragColor = vec4(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>); <span class="comment">// 返回“瑞迪施紫色”</span></span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>事实上，大多数三维引擎在运行时利用模板，串联等方式创建GLSL。 对于这个网站上的例子来说，没有复杂到要在运行时创建GLSL的程度。</p>
<p>接下来我们使用的方法将会创建一个着色器，只需要上传GLSL数据，然后编译成着色器。 你可能注意到这段代码没有任何注释，因为可以从方法名很清楚的了解方法的作用 （这里作为翻译版本我还是稍微注释一下）。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建着色器方法，输入参数：渲染上下文，着色器类型，数据源</span></div><div class="line">function createShader(<span class="keyword">gl</span>, <span class="keyword">type</span>, source) &#123;</div><div class="line">  <span class="keyword">var</span> shader = <span class="keyword">gl</span>.createShader(<span class="keyword">type</span>); <span class="comment">// 创建着色器对象</span></div><div class="line">  <span class="keyword">gl</span>.shaderSource(shader, source); <span class="comment">// 提供数据源</span></div><div class="line">  <span class="keyword">gl</span>.compileShader(shader); <span class="comment">// 编译 -&gt; 生成着色器</span></div><div class="line">  <span class="keyword">var</span> success = <span class="keyword">gl</span>.getShaderParameter(shader, <span class="keyword">gl</span>.COMPILE_STATUS);</div><div class="line">  <span class="keyword">if</span> (success) &#123;</div><div class="line">    <span class="keyword">return</span> shader;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  console.<span class="built_in">log</span>(<span class="keyword">gl</span>.getShaderInfoLog(shader));</div><div class="line">  <span class="keyword">gl</span>.deleteShader(shader);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们可以使用以上方法创建两个着色器</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var vertexShaderSource</span> = document.getElementById(<span class="string">"2d-vertex-shader"</span>).text;</div><div class="line"><span class="attribute">var fragmentShaderSource</span> = document.getElementById(<span class="string">"2d-fragment-shader"</span>).text;</div><div class="line"> </div><div class="line"><span class="attribute">var vertexShader</span> = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);</div><div class="line"><span class="attribute">var fragmentShader</span> = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);</div></pre></td></tr></table></figure>
<p>然后我们将这两个着色器 link（链接）到一个 program（着色程序）</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createProgram(<span class="keyword">gl</span>, vertexShader, fragmentShader) &#123;</div><div class="line">  <span class="keyword">var</span> <span class="keyword">program</span> = <span class="keyword">gl</span>.createProgram();</div><div class="line">  <span class="keyword">gl</span>.attachShader(<span class="keyword">program</span>, vertexShader);</div><div class="line">  <span class="keyword">gl</span>.attachShader(<span class="keyword">program</span>, fragmentShader);</div><div class="line">  <span class="keyword">gl</span>.linkProgram(<span class="keyword">program</span>);</div><div class="line">  <span class="keyword">var</span> success = <span class="keyword">gl</span>.getProgramParameter(<span class="keyword">program</span>, <span class="keyword">gl</span>.LINK_STATUS);</div><div class="line">  <span class="keyword">if</span> (success) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">program</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  console.<span class="built_in">log</span>(<span class="keyword">gl</span>.getProgramInfoLog(<span class="keyword">program</span>));</div><div class="line">  <span class="keyword">gl</span>.deleteProgram(<span class="keyword">program</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后调用它</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">program</span> = createProgram(<span class="keyword">gl</span>, vertexShader, fragmentShader);</div></pre></td></tr></table></figure>
<p>现在我们已经在GPU上创建了一个GLSL着色程序，我们还需要给它提供数据。 WebGL的主要任务就是设置好状态并为GLSL着色程序提供数据。 在这个例子中GLSL着色程序的唯一输入是一个属性值a_position。 我们要做的第一件事就是从刚才创建的GLSL着色程序中找到这个属性值所在的位置。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> positionAttributeLocation = <span class="keyword">gl</span>.getAttribLocation(<span class="keyword">program</span>, <span class="string">"a_position"</span>);</div></pre></td></tr></table></figure>
<p>寻找属性值位置（和全局属性位置）应该在初始化的时候完成，而不是在渲染循环中。属性值从缓冲中获取数据，所以我们创建一个缓冲</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">var positionBuffer</span> = gl.createBuffer();</div></pre></td></tr></table></figure>
<p>WebGL可以通过绑定点操控全局范围内的许多数据，你可以把绑定点想象成一个WebGL内部的全局变量。 首先绑定一个数据源到绑定点，然后可以引用绑定点指向该数据源。 所以让我们来绑定位置信息缓冲（下面的绑定点就是ARRAY_BUFFER）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">gl</span><span class="selector-class">.bindBuffer</span>(<span class="selector-tag">gl</span><span class="selector-class">.ARRAY_BUFFER</span>, <span class="selector-tag">positionBuffer</span>);</div></pre></td></tr></table></figure>
<p>现在我们需要通过绑定点向缓冲中存放数据</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 三个二维点坐标</span></div><div class="line">var positions = [</div><div class="line">  <span class="number">0</span>, <span class="number">0</span>,</div><div class="line">  <span class="number">0</span>, <span class="number">0.5</span>,</div><div class="line">  <span class="number">0.7</span>, <span class="number">0</span>,</div><div class="line">];</div><div class="line">gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);</div></pre></td></tr></table></figure>
<p>这里完成了一系列事情，第一件事是我们有了一个JavaScript序列positions 。 然而WebGL需要强类型数据，所以new Float32Array(positions)创建了32位浮点型数据序列， 并从positions中复制数据到序列中，然后gl.bufferData复制这些数据到GPU的positionBuffer对象上。 它最终传递到positionBuffer上是因为在前一步中我们我们将它绑定到了ARRAY_BUFFER（也就是绑定点）上。</p>
<p>最后一个参数gl.STATIC_DRAW是提示WebGL我们将怎么使用这些数据。WebGL会根据提示做出一些优化。 gl.STATIC_DRAW提示WebGL我们不会经常改变这些数据。</p>
<p>在此之上的代码是 初始化代码。这些代码在页面加载时只会运行一次。 接下来的代码是渲染代码，而这些代码将在我们每次要渲染或者绘制时执行。</p>
<h2 id="2、渲染"><a href="#2、渲染" class="headerlink" title="2、渲染"></a>2、渲染</h2><p>在绘制之前我们应该调整画布（canvas）的尺寸以匹配它的显示尺寸。画布就像图片一样有两个尺寸。 一个是它拥有的实际像素个数，另一个是它显示的大小。CSS决定画布显示的大小。 你应该尽可能用CSS设置所需画布大小 ，因为它比其它方式灵活的多。</p>
<p>为了使画布的像素数和显示大小匹配， 我这里使用了一个辅助方法，你可以在<a href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html" target="_blank" rel="external">这里</a>这里获取更多相关信息。</p>
<p>这里的例子中，有独立窗口显示的示例大多使用400x300像素大小的画布。 但是如果像稍后展示的示例那样嵌在页面中，它就会被拉伸以填满可用空间 （你也可以点击示例下方的“点此在新窗口中浏览”在独立窗口中查看示例）。 通过使用CSS调整画布尺寸可以轻松处理这些情况。</p>
<p>这里的例子中，有独立窗口显示的示例大多使用400x300像素大小的画布。 但是如果像稍后展示的示例那样嵌在页面中，它就会被拉伸以填满可用空间 （你也可以点击示例下方的“点此在新窗口中浏览”在独立窗口中查看示例）。 通过使用CSS调整画布尺寸可以轻松处理这些情况。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">webglUtils</span><span class="selector-class">.resizeCanvasToDisplaySize</span>(<span class="selector-tag">gl</span><span class="selector-class">.canvas</span>);</div></pre></td></tr></table></figure>
<p>我们需要告诉WebGL怎样把提供的gl_Position裁剪空间坐标对应到画布像素坐标， 通常我们也把画布像素坐标叫做屏幕空间。为了实现这个目的，我们只需要调用gl.viewport 方法并传递画布的当前尺寸。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">gl</span><span class="selector-class">.viewport</span>(0, 0, <span class="selector-tag">gl</span><span class="selector-class">.canvas</span><span class="selector-class">.width</span>, <span class="selector-tag">gl</span><span class="selector-class">.canvas</span><span class="selector-class">.height</span>);</div></pre></td></tr></table></figure>
<p>这样就告诉WebGL裁剪空间的 -1 -&gt; +1 分别对应到x轴的 0 -&gt; gl.canvas.width 和y轴的 0 -&gt; gl.canvas.height。</p>
<p>我们用0, 0, 0, 0清空画布，分别对应 r, g, b, alpha （红，绿，蓝，阿尔法）值， 所以在这个例子中我们让画布变透明了。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 清空画布</span></div><div class="line">gl.clearColor(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">gl.clear(gl.COLOR_BUFFER_BIT);</div></pre></td></tr></table></figure>
<p>接下来我们需要告诉WebGL怎么从我们之前准备的缓冲中获取数据给着色器中的属性。 首先我们需要启用对应属性</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gl.enableVertexAttribArray(positionAttributeLocation)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>然后指定从缓冲中读取数据的方式</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将绑定点绑定到缓冲数据（positionBuffer）</span></div><div class="line"><span class="keyword">gl</span>.bindBuffer(<span class="keyword">gl</span>.ARRAY_BUFFER, positionBuffer);</div><div class="line"> </div><div class="line"><span class="comment">// 告诉属性怎么从positionBuffer中读取数据 (ARRAY_BUFFER)</span></div><div class="line"><span class="keyword">var</span> size = 2;          <span class="comment">// 每次迭代运行提取两个单位数据</span></div><div class="line"><span class="keyword">var</span> <span class="keyword">type</span> = <span class="keyword">gl</span>.FLOAT;   <span class="comment">// 每个单位的数据类型是32位浮点型</span></div><div class="line"><span class="keyword">var</span> normalize = false; <span class="comment">// 不需要归一化数据</span></div><div class="line"><span class="keyword">var</span> stride = 0;        <span class="comment">// 0 = 移动单位数量 * 每个单位占用内存（sizeof(type)）</span></div><div class="line">                       <span class="comment">// 每次迭代运行运动多少内存到下一个数据开始点</span></div><div class="line"><span class="keyword">var</span> offset = 0;        <span class="comment">// 从缓冲起始位置开始读取</span></div><div class="line"><span class="keyword">gl</span>.vertexAttribPointer(</div><div class="line">    positionAttributeLocation, size, <span class="keyword">type</span>, normalize, stride, offset)</div></pre></td></tr></table></figure>
<p>一个隐藏信息是gl.vertexAttribPointer是将属性绑定到当前的ARRAY_BUFFER。 换句话说就是属性绑定到了positionBuffer上。这也意味着现在利用绑定点随意将 ARRAY_BUFFER绑定到其它数据上后，该属性依然从positionBuffer上读取数据。</p>
<p>从GLSL的顶点着色器中注意到a_position属性的数据类型是vec4</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_position;</div></pre></td></tr></table></figure>
<p>vec4是一个有四个浮点数据的数据类型。在JavaScript中你可以把它想象成 a_position = {x: 0, y: 0, z: 0, w: 0}。之前我们设置的size = 2， 属性默认值是0, 0, 0, 1，然后属性将会从缓冲中获取前两个值（ x 和 y ）。 z和w还是默认值 0 和 1 。</p>
<p>我们终于可以让WebGL运行我们的GLSL着色程序了。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> primitiveType = gl.TRIANGLES;</div><div class="line"><span class="built_in">var</span> <span class="built_in">offset</span> = <span class="number">0</span>;</div><div class="line"><span class="built_in">var</span> <span class="built_in">count</span> = <span class="number">3</span>;</div><div class="line">gl.drawArrays(primitiveType, <span class="built_in">offset</span>, <span class="built_in">count</span>);</div></pre></td></tr></table></figure>
<p>因为count = 3，所以顶点着色器将运行三次。 第一次运行将会从位置缓冲中读取前两个值赋给属性值a_position.x和a_position.y。 第二次运行a_position.xy将会被赋予后两个值，最后一次运行将被赋予最后两个值。</p>
<p>因为我们设置primitiveType（图元类型）为 gl.TRIANGLES（三角形）， 顶点着色器每运行三次WebGL将会根据三个gl_Position值绘制一个三角形， 不论我们的画布大小是多少，在裁剪空间中每个方向的坐标范围都是 -1 到 1 。</p>
<p>由于我们的顶点着色器仅仅是传递位置缓冲中的值给gl_Position， 所以三角形在裁剪空间中的坐标如下</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>, <span class="number">0</span>,</div><div class="line"><span class="number">0</span>, <span class="number">0.5</span>,</div><div class="line"><span class="number">0.7</span>, <span class="number">0</span>,</div></pre></td></tr></table></figure>
<p>WebGL将会把它们从裁剪空间转换到屏幕空间并在屏幕空间绘制一个三角形， 如果画布大小是400×300我们会得到类似以下的转换</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">裁剪空间            屏幕空间</div><div class="line">   <span class="number">0</span>, <span class="number">0</span>       -&gt;   <span class="number">200</span>, <span class="number">150</span></div><div class="line">   <span class="number">0</span>, <span class="number">0.5</span>     -&gt;   <span class="number">200</span>, <span class="number">225</span></div><div class="line"> <span class="number">0.7</span>, <span class="number">0</span>       -&gt;   <span class="number">340</span>, <span class="number">150</span></div></pre></td></tr></table></figure>
<p>现在WebGL将渲染出这个三角形。绘制每个像素时WebGL都将调用我们的片段着色器。 我们的片断着色器只是简单设置gl_FragColor为1, 0, 0.5, 1， 由于画布的每个通道宽度为8位，这表示WebGL最终在画布上绘制[255, 0, 127, 255]。</p>
<p>这里有一个<a href="https://codepen.io/pen/?&amp;editors=101" target="_blank" rel="external">在线示例</a></p>
<p>在上例中可以发现顶点着色器只是简单的传递了位置信息。 由于位置数据坐标就是裁剪空间中的坐标，所以顶点着色器没有做什么特别的事。 如果你想做三维渲染，你需要提供合适的着色器将三维坐标转换到裁剪空间坐标，因为WebGL只是一个光栅化API。</p>
<p>你可能会好奇为什么这个三角形从中间开始然后朝向右上方。裁剪空间的x坐标范围是 -1 到 +1. 这就意味着0在中间并且正值在它右边。</p>
<p>至于它为什么在上方，是因为裁剪空间中 -1 是最底端 +1 是最顶端， 这也意味值0在中间，正值在上方。</p>
<p>对于描述二维空间中的物体，比起裁剪空间坐标你可能更希望使用屏幕像素坐标。 所以我们来改造一下顶点着色器，让我们提供给它像素坐标而不是裁剪空间坐标。 这是我们新的顶点着色器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"2d-vertex-shader"</span> <span class="attr">type</span>=<span class="string">"notjs"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="undefined">  attribute vec4 a_position;</span></div><div class="line"><span class="undefined">  attribute vec2 a_position;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="undefined">  uniform vec2 u_resolution;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">  <span class="keyword">void</span> main() &#123;</span></div><div class="line"><span class="actionscript">    <span class="comment">// 从像素坐标转换到 0.0 到 1.0</span></span></div><div class="line"><span class="undefined">    vec2 zeroToOne = a_position / u_resolution;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">    <span class="comment">// 再把 0-&gt;1 转换 0-&gt;2</span></span></div><div class="line"><span class="undefined">    vec2 zeroToTwo = zeroToOne * 2.0;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">    <span class="comment">// 把 0-&gt;2 转换到 -1-&gt;+1 (裁剪空间)</span></span></div><div class="line"><span class="undefined">    vec2 clipSpace = zeroToTwo - 1.0;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="undefined">    gl_Position = vec4(clipSpace, 0, 1);</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里有些变化需要注意，我们将a_position改成vec2类型是因为我们只需要用x和y值。 vec2和vec4有些类似但是仅有x和y值。</p>
<p>接着我们添加了一个uniform（全局变量）叫做u_resolution，为了设置它的值我们需要找到它的位置。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resolutionUniformLocation = <span class="keyword">gl</span>.getUniformLocation(<span class="keyword">program</span>, <span class="string">"u_resolution"</span>);</div></pre></td></tr></table></figure>
<p>其余变化的应该能从注释中理解。通过设置u_resolution为画布的分辨率， 着色器将会从positionBuffer中获取像素坐标将之转换为对应的裁剪空间坐标。</p>
<p>现在我们可以将位置信息转换为像素坐标。这次我们将通过绘制两个三角形来绘制一个矩形， 每个三角形有三个点。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var positions = [</div><div class="line">  <span class="number">10</span>, <span class="number">20</span>,</div><div class="line">  <span class="number">80</span>, <span class="number">20</span>,</div><div class="line">  <span class="number">10</span>, <span class="number">30</span>,</div><div class="line">  <span class="number">10</span>, <span class="number">30</span>,</div><div class="line">  <span class="number">80</span>, <span class="number">20</span>,</div><div class="line">  <span class="number">80</span>, <span class="number">30</span>,</div><div class="line">];</div><div class="line">gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);</div></pre></td></tr></table></figure>
<p>在我们设置好使用这个着色程序后，可以设置刚才创建的全局变量的值。 gl.useProgram就与之前讲到的gl.bindBuffer相似，设置当前使用的着色程序。 之后所有类似gl.uniformXXX格式的方法都是设置当前着色程序的全局变量。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">gl</span>.useProgram(<span class="keyword">program</span>);</div><div class="line"> </div><div class="line">...</div><div class="line"> </div><div class="line"><span class="comment">// 设置全局变量 分辨率</span></div><div class="line"><span class="keyword">gl</span>.uniform2f(resolutionUniformLocation, <span class="keyword">gl</span>.canvas.width, <span class="keyword">gl</span>.canvas.height);</div></pre></td></tr></table></figure>
<p>显然我们需要告诉WebGL要运行六次顶点着色器来画两个三角形。 所以我们将count改成6。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 绘制</span></div><div class="line"><span class="keyword">var</span> primitiveType = <span class="keyword">gl</span>.TRIANGLES;</div><div class="line"><span class="keyword">var</span> offset = 0;</div><div class="line"><span class="keyword">var</span> <span class="keyword">count</span> = 6;</div><div class="line"><span class="keyword">gl</span>.drawArrays(primitiveType, offset, <span class="keyword">count</span>);</div></pre></td></tr></table></figure>
<p>这里是<a href="https://webglfundamentals.org/webgl/webgl-2d-rectangle.html" target="_blank" rel="external">结果</a></p>
<p>注意: 这个和以后的例子都将使用webgl-utils.js， 它包含了编译和链接着色器的方法。没有必要让一些<a href="https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html" target="_blank" rel="external">样板代码</a>干扰示例代码</p>
<p>你可能注意到矩形在区域左下角，WebGL认为左下角是 0，0 。 想要像传统二维API那样起点在左上角，我们只需翻转y轴即可。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gl_Position = vec4(clipSpace * vec2(<span class="number">1</span>, <span class="number">-1</span>), <span class="number">0</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>现在矩形在我们期望的位置了, <a href="https://webglfundamentals.org/webgl/webgl-2d-rectangle-top-left.html" target="_blank" rel="external">在线预览</a></p>
<p>让我们来定义一个可以生成矩形的方法，这样我们就可以调用它定义形状不一的多个矩形。 同时我们需要矩形的颜色是可设置的。</p>
<p>首先我们定义一个片断着色器，可以通过全局变量接收自定义颜色。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"2d-fragment-shader"</span> <span class="attr">type</span>=<span class="string">"notjs"</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="undefined">  precision mediump float;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="undefined">  uniform vec4 u_color;</span></div><div class="line"><span class="undefined"> </span></div><div class="line"><span class="actionscript">  <span class="keyword">void</span> main() &#123;</span></div><div class="line"><span class="undefined">    gl_FragColor = u_color;</span></div><div class="line"><span class="undefined">  &#125;</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里是一段新代码，可以随机绘制50个随机位置，随机大小，随机颜色的矩形。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> colorUniformLocation = gl.getUniformLocation(program, <span class="string">"u_color"</span>);</div><div class="line">  ...</div><div class="line"> </div><div class="line">  <span class="comment">// 绘制50个随机颜色矩形</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> ii = <span class="number">0</span>; ii &lt; <span class="number">50</span>; ++ii) &#123;</div><div class="line">    <span class="comment">// 创建一个随机矩形</span></div><div class="line">    <span class="comment">// 并将写入位置缓冲</span></div><div class="line">    <span class="comment">// 因为位置缓冲是我们绑定在</span></div><div class="line">    <span class="comment">// `ARRAY_BUFFER`绑定点上的最后一个缓冲</span></div><div class="line">    setRectangle(</div><div class="line">        gl, randomInt(<span class="number">300</span>), randomInt(<span class="number">300</span>), randomInt(<span class="number">300</span>), randomInt(<span class="number">300</span>));</div><div class="line"> </div><div class="line">    <span class="comment">// 设置一个随机颜色</span></div><div class="line">    gl.uniform4f(colorUniformLocation, <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="built_in">Math</span>.random(), <span class="number">1</span>);</div><div class="line"> </div><div class="line">    <span class="comment">// 绘制矩形</span></div><div class="line">    gl.drawArrays(gl.TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 返回 0 到 range 范围内的随机整数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomInt</span>(<span class="params">range</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * range);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 用参数生成矩形顶点并写进缓冲</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRectangle</span>(<span class="params">gl, x, y, width, height</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x1 = x;</div><div class="line">  <span class="keyword">var</span> x2 = x + width;</div><div class="line">  <span class="keyword">var</span> y1 = y;</div><div class="line">  <span class="keyword">var</span> y2 = y + height;</div><div class="line"> </div><div class="line">  <span class="comment">// 注意: gl.bufferData(gl.ARRAY_BUFFER, ...) 将会影响到</span></div><div class="line">  <span class="comment">// 当前绑定点`ARRAY_BUFFER`的绑定缓冲</span></div><div class="line">  <span class="comment">// 目前我们只有一个缓冲，如果我们有多个缓冲</span></div><div class="line">  <span class="comment">// 我们需要先将所需缓冲绑定到`ARRAY_BUFFER`</span></div><div class="line"> </div><div class="line">  gl.bufferData(gl.ARRAY_BUFFER, <span class="keyword">new</span> <span class="built_in">Float32Array</span>([</div><div class="line">     x1, y1,</div><div class="line">     x2, y1,</div><div class="line">     x1, y2,</div><div class="line">     x1, y2,</div><div class="line">     x2, y1,</div><div class="line">     x2, y2]), gl.STATIC_DRAW);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是50个矩形。<a href="https://webglfundamentals.org/webgl/webgl-2d-rectangles.html" target="_blank" rel="external">在线预览</a></p>
<p>我希望你能体会到WebGL其实是一个非常简单的API。好吧，“简单”可能是一个不恰当的描述。 它做的是一件简单的事，它仅仅运行用户提供的两个方法，一个顶点着色器和一个片断着色器， 去绘制点，线和三角形。虽然做三维可以变得很复杂，但是这种复杂只是作为程序员的你， 是一种复杂形式的“着色器”。WebGL API只做光栅化处理并且在概念上十分容易理解。</p>
<p>我们简单的示例向你展示了怎么给属性和两个全局变量提供数据。它和多个属性以及多个全局变量的原理一致。 在这篇文章的开始部分，我们还提到了varyings（可变量）和textures（纹理），这些将会在随后的课程中出现。</p>
<p>在我们继续之前我想提醒你们，上例中用setRectangle更新缓冲数据的方式在大多数程序中并不常见。 我这么用只是因为在这个例子中，为了解释GLSL接收像素坐标并通过少量数学运算得到期望结果， 这可能是最简单的方式。这不是常规做法，这里有一些常用的例子，你可以 继续阅读并发现在WebGL中<a href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-2d-translation.html" target="_blank" rel="external">移动，旋转，缩放物体的通用方式</a>。</p>
<p>无路你是不是web开发新手都请查看<a href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-setup-and-installation" target="_blank" rel="external">设置和安装</a>， 获取一些WebGL开发的小技巧。</p>
<p>如果你是100%的WebGL新手甚至不知道GLSL或者着色器是什么，或者GPU是做什么的，查看 关于<a href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html" target="_blank" rel="external">WebGL工作原理的基础知识</a>.</p>
<p>你至少应简短浏览一下示例中用到最多的模板代码。 你也可以快速浏览一下<a href="https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html" target="_blank" rel="external">怎样绘制多个物体</a>， 以便了解WebGL应用程序的典型结构，不幸的是在此之前几乎所有的例子都只绘制一个物体， 所以没有展示那个结构。</p>
<p>除此以外这里有两个方向，如果你对图像处理改兴趣，我会向你展示 怎样做一些图像处理。 如果你想学习平移，旋转和缩放最终到三维那就从这里开始。</p>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/js/">JS</a></li>
         
          <li><a href="/tags/canvas/">Canvas</a></li>
         
          <li><a href="/tags/webgl/">Webgl</a></li>
         
          <li><a href="/tags/vue/">Vue</a></li>
         
          <li><a href="/tags/react/">React</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、WebGL-Hello-World"><span class="toc-number">1.</span> <span class="toc-text">1、WebGL Hello World</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、渲染"><span class="toc-number">2.</span> <span class="toc-text">2、渲染</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://yoursite.com/2017/08/17/webgl基础概念/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://yoursite.com/2017/08/17/webgl基础概念/&text=webgl基础概念"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://yoursite.com/2017/08/17/webgl基础概念/&is_video=false&description=webgl基础概念"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=webgl基础概念&body=Check out this article: http://yoursite.com/2017/08/17/webgl基础概念/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://yoursite.com/2017/08/17/webgl基础概念/&title=webgl基础概念"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://yoursite.com/2017/08/17/webgl基础概念/&name=webgl基础概念&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2017 zhouyufei
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/js/">JS</a></li>
         
          <li><a href="/tags/canvas/">Canvas</a></li>
         
          <li><a href="/tags/webgl/">Webgl</a></li>
         
          <li><a href="/tags/vue/">Vue</a></li>
         
          <li><a href="/tags/react/">React</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>
<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


